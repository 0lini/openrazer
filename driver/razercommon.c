/*
 * Copyright (c) 2015 Terry Cain <terry@terrys-home.co.uk>
 *               2015 Tim Theede <pez2001@voyagerproject.de>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 */
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/usb/input.h>
#include <linux/hid.h>

#include "razercommon.h"

/**
 * Send USB control report to the keyboard
 */
// USUALLY index = 0x02
// FIREFLY is 0
int razer_send_control_msg(struct usb_device *usb_dev,void const *data, uint report_index, ulong wait_min, ulong wait_max)
{
	uint request = HID_REQ_SET_REPORT; // 0x09
	uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21
    uint value = 0x300;
    uint size = RAZER_USB_REPORT_LEN;
    char *buf;
    int len;

    buf = kmemdup(data, size, GFP_KERNEL);
    if (buf == NULL)
        return -ENOMEM;

    // Send usb control message
    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
            request,      // Request
            request_type, // RequestType
            value,        // Value
            report_index, // Index
            buf,          // Data
            size,         // Length
            USB_CTRL_SET_TIMEOUT);

    // Wait
    usleep_range(wait_min, wait_max);

    kfree(buf);
    if(len!=size)
        printk(KERN_WARNING "razer driver: Device data transfer failed.");

    return ((len < 0) ? len : ((len != size) ? -EIO : 0));
}

/**
 * Calculate the checksum for the usb message
 *
 * Checksum byte is stored in the 2nd last byte in the messages payload.
 * The checksum is generated by XORing all the bytes in the report starting
 * at byte number 2 (0 based) and ending at byte 88.
 */
unsigned char razer_calculate_crc(struct razer_report *report)
{
    /*second to last byte of report is a simple checksum*/
    /*just xor all bytes up with overflow and you are done*/
    unsigned char crc = 0;
    unsigned char *_report = (unsigned char*)report;

    unsigned int i;
    for(i = 2; i < 88; i++)
    {
        crc ^= _report[i];
    }

    return crc;
}

/**
 * Prepare the USB report
 *
 * The razer_report structure is zero'd and the ID byte is set to 0xFF
 * and the reserved2 byte is set to 0x03
 */
void razer_prepare_report(struct razer_report *report)
{
   /*fill static fields of report*/
   memset(report, 0, sizeof(struct razer_report));
   report->id = 0xFF;
   report->reserved2 = 0x03;
}

/**
 * Get a response from the razer device
 *
 * Makes a request like normal, this must change a variable in the device as then we
 * tell it give us data and it gives us a report.
 *
 * Supported Devices:
 *   Razer Chroma
 *   Razer Mamba
 *   Razer BlackWidow Ultimate 2013*
 *   Razer Firefly*
 *
 * Request report is the report sent to the device specifing what response we want
 * Response report will get populated with a response
 *
 * Returns 0 when successful, 1 if the report length is invalid.
 */
int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)
{
	uint request = HID_REQ_GET_REPORT; // 0x01
	uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; // 0xA1
    uint value = 0x300;
    
    uint size = RAZER_USB_REPORT_LEN; // 0x90
    int len;
    int retval;
    int result = 0;

    memset(response_report, 0, sizeof(struct razer_report));

    // Send the request to the device.
    // TODO look to see if index needs to be different for the request and the response
    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);

    // Now ask for reponse
    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),
          request,         // Request
          request_type,    // RequestType
          value,           // Value
          response_index,  // Index
          response_report, // Data
          size, 
          USB_CTRL_SET_TIMEOUT);

    usleep_range(wait_min, wait_max);

    // Error if report is wrong length
    if(len != 90)
    {
        printk(KERN_WARNING "razer driver: Invalid USB repsonse. USB Report length: %d\n", len);
        result = 1;
    }

    return result;
}

/**
 * Print report to syslog
 */
void print_erroneous_report(struct razer_report* report, char* driver_name, char* message)
{
    printk(KERN_WARNING "%s: %s. Start Marker: %02x id: %02x Num Params: %02x Reserved: %02x Command: %02x Sub Command: %02x Param 1: %02x .\n",
        driver_name,
        message,
        report->report_start_marker,
        report->id,
        report->parameter_bytes_num,
        report->reserved2,
        report->command,
        report->sub_command,
        report->command_parameters[0]);
}






















